[{"content":"cmake使用记录 cmake使用模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #CMake的最低版本要求 cmake_minimum_required(VERSION 3.0) #项目名称 project(tingx) #设置版本是 Debug 还是 Release set(CMAKE_BUILD_TYPE \u0026#34;Debug\u0026#34;) file(GLOB_RECURSE SRC_FILES ${PROJECT_SOURCE_DIR}/src/**.cc ${PROJECT_SOURCE_DIR}/src/**.hpp ${PROJECT_SOURCE_DIR}/src/**.h) # 移除某些文件 file(GLOB_RECURSE MAINS src/*main.cc) list(REMOVE_ITEM LIBRARY ${MAINS}) # msvc 按文件夹分组 macro(source_group_by_dir source_files) if(MSVC) set(sgbd_cur_dir ${CMAKE_CURRENT_SOURCE_DIR}) foreach(sgbd_file ${${source_files}}) string(REGEX REPLACE ${sgbd_cur_dir}/\\(.*\\) \\\\1 sgbd_fpath ${sgbd_file}) string(REGEX REPLACE \u0026#34;\\(.*\\)/.*\u0026#34; \\\\1 sgbd_group_name ${sgbd_fpath}) string(COMPARE EQUAL ${sgbd_fpath} ${sgbd_group_name} sgbd_nogroup) string(REPLACE \u0026#34;/\u0026#34; \u0026#34;\\\\\u0026#34; sgbd_group_name ${sgbd_group_name}) if(sgbd_nogroup) set(sgbd_group_name \u0026#34;\\\\\u0026#34;) endif(sgbd_nogroup) source_group(${sgbd_group_name} FILES ${sgbd_file}) endforeach(sgbd_file) endif(MSVC) endmacro(source_group_by_dir) #设置包含目录 include_directories(${PROJECT_SOURCE_DIR}/src) #设置输出目录 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/build) #添加编译参数,比如add_definitions(-DDEBUG)将在gcc命令行添加DEBUG宏定义 add_definitions(-g) #添加可执行文件 add_executable(tingx ${SRC_FILES}) add_executable(client ${PROJECT_SOURCE_DIR}/test/client.cc) cmake预定义变量 以下假设项目文件夹路径为/home/name/project\n变量 值 PROJECT_SOURCE_DIR /home/name/project 问题汇总 cmake+vscode配置后源代码中显示头文件找不到 在项目文件夹下.vscode中settings.json中添加行\u0026quot;C_Cpp.default.configurationProvider\u0026quot;: \u0026ldquo;vector-of-bool.cmake-tools\u0026rdquo;\n","date":"2022-03-03T00:00:00Z","permalink":"https://nu11able.github.io/p/cmake%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"cmake使用记录"},{"content":"Git笔记 说明 1、以下举例所用的仓库地址均为：git@github.com:yourname/repo.git 2、以下举例所用的仓库地址均为：github_repo\n新建仓库 从github中新创建仓库后可以看到下图\n本地没有代码从0开始 1 2 3 4 5 6 7 echo \u0026#34;# test\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main # 修改master分支名字为main git remote add origin git@github.com:yourname/repo.git git push -u origin main 本地已有代码 1 2 3 4 5 6 git remote add origin git@github.com:yourname/repo.git git branch -M main # 可以跳过 git push -u origin main # or git push -u origin master # 默认存在master分支 git remote 列出远程仓库 1 2 git remote git remote -v # 列出详细信息 添加/删除远程仓库地址 1 2 git remote add name git@github.com:yourname/repo.git git remote remove name 修改仓库名字 1 git remote rename oldname newname git rm 删除对某个文件的跟踪 1 2 3 4 git rm --cached somefile # 如果是文件夹 git rm -r --cached somefile git reset 撤销commit 1 2 git reset --soft HEAD^ # 撤销一次commit git reset --soft HEAD~2 # 撤销两次commit 提交完了之后发现文件名不对，或者说对某个文件做了轻微的改动\n1 2 git add . # 添加所有新的修改到暂存区 git commit --amend 常见问题 命令 功能 修复github只有新建仓库时才有小绿点贡献而commit没有 1 git filter-branch --env-filter \u0026#39;GIT_AUTHOR_EMAIL=\u0026#34;your_email@email\u0026#34;;GIT_AUTHOR_NAME=\u0026#34;your_name\u0026#34;;\u0026#39; ","date":"2022-02-26T02:03:00Z","permalink":"https://nu11able.github.io/p/git-%E7%AC%94%E8%AE%B0/","title":"Git 笔记"},{"content":"Tips cpu对各个部件的控制其实就是对各部件的内存地址空间进行数据的读写\n8086CPU有14个寄存器AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW(flag寄存器)\n8086CPU有20位地址总线，但其又是16位结构，所以地址加法器采用物理地址=段地址*16+偏移地址(我们所看到的数据中以16进制来表示，20根地址线达到1M寻址能力需要使用5位十六进制数表示，而8086CPU每次最多只能传递4位十六进制数，所以其在内部使用两个十六位的地址来合成二十位地址)\n所谓的段地址中的“段”并不意味着内存被划分为了一个个的段内存并没有分段，只是因为CPU的寻址方式才有了段地址这个概念，仔细想一想偏移地址最大为FFFFH，这意味着一个段可能最大也就64kb，那我想要访问其他地址怎么办？这个时候就只能改动段地址(想象一根线，你可以在其上选两个点，除了最后一小段第一个点随便选，第二个点只能在第一个点的某一范围内选)\n任意时刻CS,IP指向的内容都当做指令执行，既CP:IP总是指向即将被CPU执行的指令，执行之后IP会自动增加(当然也可以改动CS:IP的指向，想想函数之间的跳转)mov 指令不能够设置CS:IP的值，jmp可以\n8086CPU不支持将数据直接送入段寄存器的操作，例如mov ds,1000H mov cs,00FFH是非法的\n8086CPU的入栈和出栈都是以字为单位进行的(既2byte 16位二进制 因为它是16位CPU？32位的CPU就是以4byte位单位，既4byte位一个字？)\nPOP和PUSH指令用于出栈和入栈,涉及寄存器SS:SP，任意时刻SS:SP 始终指向栈顶元素执行PUSH或POP和SP会自动增减入栈时，栈顶从高地址向低地址方向增长,8086CPU不会检查栈顶是否超界，需要我们自己控制\n在8086CPU中只有bx,si,di和bp可以用在\u0026quot;[]\u0026ldquo;中用来进行内存单元的寻址\n在没有寄存器名存在的情况下，用操作符 X ptr指明内存单元的长度(X可以为byte或word) mov word ptr [bx],2 或inc byte ptr [bx]\n一般来说，我们可以用[bx + idata + si]的方式来访问结构体中的数据。用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如[bx].idata [bx].idata[si]\n在“[]”中bx,si,di和bp可以单独出现，或只能以4种组合出现\n1 2 3 4 5 6 7 8 9 10 11 12 mov ax,[bx] mox ax,[si] mox ax,[di] mox ax,[bp] mov ax,[bx + si] mox ax,[bx + di] mox ax,[bp + si] mox ax,[bp + di] mov ax,[bx + si + idata] mox ax,[bx + di + idata] mox ax,[bp + si + idata] mox ax,[bp + di + idata] 下面的指令是错误的\n1 2 mov ax,[bx+bp] mov ax,[si+di] 只要在[\u0026hellip;]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中\n寄存器 作用 是否可分为两个八位 AX 通用寄存器 是 AH AL BX 通用寄存器 是 BH BL CX 通用寄存器 是 CH CL DX 通用寄存器 是 DH DL CS 代码段寄存器 IP 指令指针寄存器 DS 数据段寄存器 SS 栈段寄存器 SP 栈顶指针 任意时刻SS:SP始终指向栈顶 SI 与BX功能相近 不能分为两个八位寄存器 DI 与BX功能相近 不能分为两个八位寄存器 BP 用在[\u0026hellip;]寻址中? 只要在[\u0026hellip;]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中 PSW (flag寄存器) 汇编指令汇总 汇编指令 控制CPU完成的操作 描述 mov ax,18 将18送入寄存器AX AX=18 add ax,[0] 将AX中的数值加DS:0地址处的值结果存入AX AX=AX+[ds*16+0] sub ax,bx 将AX中的数据减去BX中的数据后结果存入AX mul reg/内存单元 乘法指令 div reg/内存单元 除法指令 push ax 将AX的值入栈 (1)SP=SP-2 (2)[SS*16+SP]=AX pop ax 将栈顶数据送入AX (1)AX=[SS*16+SP] (2)SP=SP+2 inc bx BX中的内容加1 dec bx BX中的内容减1 shl 操作数,移动位数 逻辑左移指令 将移出的一位写入cf低位补0,如果移动位数大于1则必须将移动位数放入al shr 操作数,移动位数 逻辑右移指令 将移出的一位写入cf低位补0,如果移动位数大于1则必须将移动位数放入al and ax,bx 按位与运算，将结果存入ax or ax,bx 按位或运算，将结果存入ax offset 标号 由编译器处理功能是取得标号的偏移地址 seg 标号 由编译器处理功能是取得标号的段地址 adc 操作对象1,操作对象2 操作对象1=操作对象1+操作对象2+CF sbb 操作对象1,操作对象2 操作对象1=操作对象1-操作对象2-CF cmp 操作对象1,操作对象2 相当于减法指令但不保存结果但会对标志寄存器产生影响 cld 将标志寄存器df位置0 std 将标志寄存器df位置1 cli 将标志寄存器if位置0 sti 将标志寄存器if位置1 pushf 将标志寄存器压栈 popf 将栈中数据送入标志寄存器 loop 标号 循环 (1)CX=CX-1 (2)若CX不为零则转至标号处，否则向下执行 jmp 段地址:偏移地 同时修改CS:IP 无条件转移指令(只能在debug中使用,不能在源程序中使用) jmp 某一合法寄存器 仅修改IP 无条件转移指令,转移目的地址在寄存器中 jmp short 标号 段内短转移8位位移，仅修改IP，依据位移进行转移 jmp near ptr 标号 段内近转移16位位移，仅修改IP，依据位移进行转移 jmp far ptr 标号 段间转移，同时修改CS和IP,转移目的地址在指令中 jmp word ptr 内存单元地址 段内转移，仅修改IP,转移目的地址在内存中 jmp dword ptr 内存单元地址 CS=(内存单元地址+2) IP=内存单元地址 段间转移，同时修改CS和IP,转移目的地址在内存中 jcxz 标号 用法:IP=IP+8位位移 有条件转移指令,所有的有条件转移指令都是短转移,如果CX=0,转移到标号处执行 ret 修改IP内容,实现近转移 (1)IP=SS*16+SP (2)SP=SP+2 retf 修改CS和IP内容,实现远转移 (1)IP=SS*16+SP (2)SP=SP+2 (3)CS=SS*16+SP (4)SP=SP+2 iret 通常和硬件自动完成的中断过程配合使用 (1)pop IP (2)pop CS (3)popf call 标号/16位reg 将当前IP或CS和IP压入栈并转移(call不能实现短转移) (1)SP=SP-2 SS*16+SP=IP (2)IP=IP+16位位移/reg call far ptr 标号 实现段间转移 (2)SP=SP-2 SS16+SP=CS SP=SP-2 SS16+SP=IP (2)设置CS 设置IP call word ptr 内存单元地址 push IP jmp word ptr 内存单元地址 call dword ptr 内存单元地址 push CS push IP jmp dword ptr 内存单元地址 (loop以及loop之后的的指令都是转移指令)\n补充 div： (1)除数有8位或16位，在一个寄存器或内存单元中 (2)被除数:默认放在ax中(除数位8位，被除数为16位)或放在AX和DX中(除数位16位，被除数为32位，DX存高16位AX存低16位) (3)如果除数为8位，AL存商AH存余数；如果除数为16位，AX存商DX存余数。\nmul： (1)两个数要么都是8位要么都是16位 (2)如果是8/16位，一个默认放在AL/AX中，另一个默认放在8位/16位reg或内存单元字节中 (3)如果为8位，结果默认放在AX,如果是16位DX默认放高位AX默认放低位。\nflag寄存器 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF 溢出标志位 方向标志位 可屏蔽中断标志 TF 符号标志位 0标志位 AF 奇偶标志位PF 进位标志位 记录相关命令执行后结果是否溢出,如果溢出OF=1否则为0 控制每次操作后si,di的增减，如果df=0每次操作后si、di递增否则递减 IF TF 记录相关命令执行后结果是否为负,如果为负SF=1否则为0 记录相关命令执行后结果是否为0,如结果为0，那么ZF=1否则ZF=0 AF 记录相关命令执行后结果所有bit为中1的个数是否为偶数,如果为偶数PF=1否则为0 记录运算结果向更高位的进位值或向更高位的借位值 检测比较结果的条件转移指令 指令 含义 检测的相关标志位 je 等于则转移 zf=1 jne 不等于则 转移 zf=0 jb 低于则转移 cf=1 jnb 不低于则转移 cf=0 ja 高于则转移 cf=0且zf=0 jna 不高于则转移 cf=1或zf=1 助记:j-\u0026gt;jump,e-\u0026gt;equal,n-\u0026gt;not,b-\u0026gt;below,a-\u0026gt;above 汇编程序的编写 源程序-\u0026gt;编译-\u0026gt;连接-\u0026gt;执行\n汇编语言中包含两种指令，一种是汇编指令，一种是伪指令，汇编指令最终是要被CPU执行的，为伪指令由编译器来执行\n汇编源程序中，数据不能以字母开头，所以要在前面加0。如A000h应该写为0A000h。\n在汇编源程序中，如果希望在\u0026rdquo;[]\u0026ldquo;中直接给出内存单元的偏移地址，则需要在\u0026rdquo;[]\u0026ldquo;前面显式的给出段地址所在的段寄存器。如 mov ax,ds:[0] (在汇编语言中称之为段前缀)\ndb:定义一个字节 dw:定义一个字 dd:定义两个字 dup:用来进行数据重复db 3 dup(0)定义了3个字节，他们的值都是0，相当于db 0,0,0\nS:nop 中nop代表no operation,空操作占用一个机器周期\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 assume cs:codeseg codeseg segment # 2*(123+456) mov ax,0123H mov bx,0456H add ax,bx add ax,ax mov ax,4c00H int 21H codeseg ends end 1 2 3 4 5 ;假设b是一个标号 b: db 10 dup(0) mov ax,b mov b:[2],ax ;在指令中使用标号,它相当于一个地址同时还指定了长度 ##伪指令\n(1) XXX segment : : XXX ends\nsegment和ends是成对使用的伪指令，这是在写可被编译器编译的汇编程序时必须用到的一对伪指令。segment和ends的功能是定义一个段，segment说明一个段的开始，ends说明一个段的结束。一个段必须有名称标记，使用格式为：\n1 2 3 段名 segment : 段名 ends 利用此方法将代码段、数据段、栈段分隔开 (2) end\nend是一个汇编程序结束的标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。(如果源程序有多个代码段，在end后面加上标号，以指定程序入口)\n(3) assume\n这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment\u0026hellip;ends 定义的段相关联\n(4) 标号\n汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codeseg”。一个标号指代了一个地址。比如codeseg在segment前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址\n(5) 程序返回\n1 2 mov ax,4c00H int 21H 端口 端口地址范围0~65535(oxffff) 端口只能用in和out来从端口读取数据和往端口写入数据 在in和out指令中，只能用ax或al来存放从端口中读入的数据或要发送到端口的数据 对0~255以内的端口进行读写时:\n1 2 in al,20h ;从20h端口读一个字节 out 20h,al ;往20端口写入一个字节 对256~65535的端口进行读写时,端口号放在dx中\n1 2 3 mov dx,3f8h in al,dx ;从3f8h端口读一个字节 out dx,al ;向3f8h端口写一个字节 ","date":"2022-02-23T00:00:00Z","permalink":"https://nu11able.github.io/p/asm/","title":"asm"},{"content":"FAQ Q:用户模式和内核模式有什么区别\nA:虚拟地址在用户模式时映射到用户程序的内存区域，在内核模式时则映射到内核程序的内存区域。内存映射的切换有MMU来实现\nQ:系统调用到底是什么\nA:用户程序由用户进程处理，无法访问加载内核程序的区域，也就无法执行由内核实现的功能。为了访问内核功能，用户程序必须通过系统调用向内核提出访问内核功能的请求\nQ:父进程为什么一定要得到子进程的处理结果才能够将子进程清理掉\nQ:PPDA(per process data area)和APR(active page register)到底是什么\n第二章 进程 内核程序在系统启动时被读取到内存中 第三章 进程的管理1 父进程在子进程结束时取其结束状态并释放进程资源 子进程与父进程共享代码段(如果子进程执行了其他程序，那么这种关系将被打破)但有自己的数据段(写时复制技术)。 ","date":"2022-02-23T00:00:00Z","permalink":"https://nu11able.github.io/p/unix%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","title":"unix内核源码剖析"},{"content":"Unix网络编程基础篇(例子) 一个简单的echo client/server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // server.cpp // 单进程 #include\u0026lt;iostream\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;strings.h\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } int main() { int sock_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in ser_addr, clnt_addr; unsigned addr_len = sizeof(struct sockaddr_in), clnt_addr_len; bzero(\u0026amp;ser_addr, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.sin_port = htons(65535); ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); bind(sock_fd, (struct sockaddr*)\u0026amp;ser_addr, sizeof(ser_addr)); listen(sock_fd, 10); for (;;) { int client_fd = accept(sock_fd, (struct sockaddr*)\u0026amp;clnt_addr, \u0026amp;addr_len); string client_tag(100, 0); inet_ntop(AF_INET, \u0026amp;clnt_addr.sin_addr.s_addr, \u0026amp;client_tag[0], client_tag.capacity()); client_tag += to_string(ntohs(clnt_addr.sin_port)); cout \u0026lt;\u0026lt; \u0026#34;connected from \u0026#34; \u0026lt;\u0026lt; client_tag \u0026lt;\u0026lt; endl; client_tag.push_back(\u0026#39;\u0026gt;\u0026#39;); int n; string recv_buf(1024, 0); while ((n = read(client_fd, \u0026amp;recv_buf[0], recv_buf.capacity()))) { cout \u0026lt;\u0026lt; client_tag; output(recv_buf, n); cout \u0026lt;\u0026lt; endl; n = write(client_fd, \u0026amp;recv_buf[0], n); } close(client_fd); } close(sock_fd); return 0; } 若没有特殊说明后续实现的server均可用此SimpleClient作为客户端连接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // SimpleClient.cpp #include\u0026lt;iostream\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;strings.h\u0026gt; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } int main() { int sock_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in serv, clnt; bzero(\u0026amp;serv, sizeof(serv)); serv.sin_family = AF_INET, serv.sin_port = htons(65535); inet_pton(AF_INET, \u0026#34;127.0.0.1\u0026#34;, \u0026amp;serv.sin_addr); connect(sock_fd, (struct sockaddr*)\u0026amp;serv, sizeof(serv)); string buffer(1024, 0); cin \u0026gt;\u0026gt; buffer; int n; while (buffer != \u0026#34;exit\u0026#34;) { write(sock_fd, \u0026amp;buffer[0], buffer.length()); n = read(sock_fd, \u0026amp;buffer[0], buffer.capacity()); cout \u0026lt;\u0026lt; \u0026#34;server\u0026gt;\u0026#34;; output(buffer, n); cout \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; buffer; } close(sock_fd); return 0; } 一个简单的多进程echo服务器 注意点：使用fork创建子进程后要在主进程中要记得调用wait等函来等待子进程\n当子进程走完了自己的生命周期后,它会执行exit()系统调用,内核释放该进程所有的资源,包括打开的文件, 占用的内存等。但是仍然为其保留一定的信息(包括进程号the process ID,退出码exit code,退出状态the terminationstatus of the process, 运行时间the amount of CPU time taken by the process等),这些数据会一直保留到系统将它传递给它的父进程为止, 直到父进程通过wait / waitpid来取时才释放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include\u0026lt;iostream\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;strings.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } int main() { int sock_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in ser_addr, clnt_addr; unsigned addr_len = sizeof(struct sockaddr_in), clnt_addr_len; bzero(\u0026amp;ser_addr, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.sin_port = htons(65535); ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); bind(sock_fd, (struct sockaddr*)\u0026amp;ser_addr, sizeof(ser_addr)); listen(sock_fd, 10); vector\u0026lt;int\u0026gt; children; for (;;) { int client_fd = accept(sock_fd, (struct sockaddr*)\u0026amp;clnt_addr, \u0026amp;addr_len); string client_tag(100, 0); inet_ntop(AF_INET, \u0026amp;clnt_addr.sin_addr.s_addr, \u0026amp;client_tag[0], client_tag.capacity()); client_tag += to_string(ntohs(clnt_addr.sin_port)); cout \u0026lt;\u0026lt; \u0026#34;connected from \u0026#34; \u0026lt;\u0026lt; client_tag \u0026lt;\u0026lt; endl; int pid = fork(); if (pid == 0) { client_tag.push_back(\u0026#39;\u0026gt;\u0026#39;); int n; string recv_buf(1024, 0); while ((n = read(client_fd, \u0026amp;recv_buf[0], recv_buf.capacity()))) { cout \u0026lt;\u0026lt; client_tag; output(recv_buf, n); cout \u0026lt;\u0026lt; endl; n = write(client_fd, \u0026amp;recv_buf[0], n); } close(client_fd); exit(0); } children.push_back(pid); cout \u0026lt;\u0026lt; client_tag \u0026lt;\u0026lt; \u0026#34; is working on child process \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; endl; close(client_fd); } close(sock_fd); while (!children.empty()) { int status; int pid = wait(\u0026amp;status); children.erase(find(children.begin(), children.end(), pid)); if (WIFEXITED(status)) { cout \u0026lt;\u0026lt; \u0026#34;child \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; \u0026#34; terminated normally\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;child \u0026#34; \u0026lt;\u0026lt; pid \u0026lt;\u0026lt; \u0026#34; terminated with \u0026#34; \u0026lt;\u0026lt; WEXITSTATUS(status) \u0026lt;\u0026lt; endl; } } cout \u0026lt;\u0026lt; \u0026#34;server exit\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 基于select的非阻塞echo服务器 上述的accept函数以及read函数都将阻塞我们的进程，为了同时处理多个请求我们不得不创建多个进程。我们无法知道套接字上的读写事件何时发生，而select可以像一个像一个闹钟一样通知我们有我们关注的事件发生\nint select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);\nvoid FD_CLR(int fd, fd_set *set);\nint FD_ISSET(int fd, fd_set *set);\nvoid FD_SET(int fd, fd_set *set);\nvoid FD_ZERO(fd_set *set);\nselect限制：select使用fd_set数据类型作为描述符集，通常是一个数组，它的大小由FD_SETSIZE常值定义，通常为1024(即select最多能够同时监听的同一类型的最大数量为FD_SETSIZE)\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\nflags取值为MSG_DONTWAIT时可以实现非阻塞通信 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include\u0026lt;iostream\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;sys/wait.h\u0026gt; #include\u0026lt;sys/select.h\u0026gt; #include\u0026lt;strings.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } int main() { int sock_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in ser_addr, clnt_addr; unsigned addr_len = sizeof(struct sockaddr_in), clnt_addr_len; bzero(\u0026amp;ser_addr, sizeof(ser_addr)); ser_addr.sin_family = AF_INET; ser_addr.sin_port = htons(65535); ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); bind(sock_fd, (struct sockaddr*)\u0026amp;ser_addr, sizeof(ser_addr)); listen(sock_fd, 10); fd_set allset, rset; map\u0026lt;int, string\u0026gt; client_names; int allfd[FD_SETSIZE]; for (int i = 0; i \u0026lt; FD_SETSIZE; i++) allfd[i] = -1; FD_ZERO(\u0026amp;allset); FD_SET(sock_fd, \u0026amp;allset); int maxfd = sock_fd; for (;;) { rset = allset; int ready = select(maxfd + 1, \u0026amp;rset, NULL, NULL, NULL); if (FD_ISSET(sock_fd, \u0026amp;rset)) { int client_fd = accept(sock_fd, (struct sockaddr*)\u0026amp;clnt_addr, \u0026amp;addr_len); string client_tag(100, 0); inet_ntop(AF_INET, \u0026amp;clnt_addr.sin_addr.s_addr, \u0026amp;client_tag[0], client_tag.capacity()); client_tag.push_back(\u0026#39;:\u0026#39;); client_tag += to_string(ntohs(clnt_addr.sin_port)); cout \u0026lt;\u0026lt; \u0026#34;connected from \u0026#34; \u0026lt;\u0026lt; client_tag \u0026lt;\u0026lt; endl; bool unset = true; for (int i = 0; i \u0026lt; FD_SETSIZE; ++i) { if (allfd[i] \u0026gt; 0) { cout \u0026lt;\u0026lt; allfd[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; continue; }; allfd[i] = client_fd; maxfd = max(maxfd, client_fd); unset = false; client_names[client_fd] = client_tag; FD_SET(client_fd, \u0026amp;allset); break; } if (unset) { cout \u0026lt;\u0026lt; \u0026#34;too many clients\u0026#34; \u0026lt;\u0026lt; endl; close(client_fd); } ready--; } int n; string recv_buf(1024, 0); for (int i = 0; i \u0026lt; FD_SETSIZE \u0026amp;\u0026amp; ready; ++i) { if (allfd[i] \u0026lt; 0 || !FD_ISSET(allfd[i], \u0026amp;rset)) continue; while ((n = recv(allfd[i], \u0026amp;recv_buf[0], recv_buf.capacity(), MSG_DONTWAIT)) \u0026gt; 0) { cout \u0026lt;\u0026lt; client_names[allfd[i]] \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34;; output(recv_buf, n); cout \u0026lt;\u0026lt; endl; n = write(allfd[i], \u0026amp;recv_buf[0], n); } if (n == 0 || errno != EAGAIN) { if (n == 0) cout \u0026lt;\u0026lt; client_names[allfd[i]] \u0026lt;\u0026lt; \u0026#34; closed\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; endl; FD_CLR(allfd[i], \u0026amp;allset); close(allfd[i]); allfd[i] = -1; } ready--; } } close(sock_fd); cout \u0026lt;\u0026lt; \u0026#34;server exit\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 基于poll的非阻塞echo服务器 回顾6.3结尾处我们就FD_SETSIZE以及就每个描述符集中最大描述符数目相比每个进 程中最大描述符数目展开了讨论。有了poll就不再由那样的问题了，因为分配一个 pollfd结构的数组并把数组中元素的数目通知内核成了调用者的责任。内核不再需要 知道类似fd_set的固定大小的数据类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;poll.h\u0026gt; #include\u0026lt;signal.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;strings.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; const short PORT = 65535; const int LISTENQ = 10; const int BUFFER_SIZE = 1024; bool exiting = false; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } void exit_handler(int signum) { exiting = true; } int main() { signal(SIGINT, exit_handler); int serv_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in serv_addr, clnt_addr; int clnt_fd; unsigned addr_len = sizeof(struct sockaddr_in); bzero(\u0026amp;serv_addr, addr_len); serv_addr.sin_port = htons(PORT); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(serv_fd, (struct sockaddr*)\u0026amp;serv_addr, addr_len) \u0026lt; 0) { perror(\u0026#34;bind\u0026#34;); exit(0); } listen(serv_fd, LISTENQ); vector\u0026lt;struct pollfd\u0026gt; events; vector\u0026lt;string\u0026gt; names; struct pollfd poll_temp; poll_temp.fd = serv_fd; poll_temp.events = POLLRDNORM; events.push_back(poll_temp); names.push_back(\u0026#34;server\u0026#34;); for (;;) { // Specifying a negative value in timeout means an infinite timeout. Specifying a timeout of zero causes poll() to return // immediately, even if no file descriptors are ready. int nready = poll(\u0026amp;events[0], events.size(), -1); if (events[0].revents \u0026amp; POLLRDNORM) { // new client connection clnt_fd = accept(serv_fd, (struct sockaddr*)\u0026amp;clnt_addr, \u0026amp;addr_len); auto iter = find_if(events.begin(), events.end(), [](auto \u0026amp;iter){ return iter.fd == -1; }); if (iter != events.end()) { iter-\u0026gt;fd = clnt_fd; iter-\u0026gt;events = POLLRDNORM; } else { events.push_back(poll_temp); iter = events.end() - 1; names.push_back(string(\u0026#34;\u0026#34;)); } iter-\u0026gt;fd = clnt_fd; iter-\u0026gt;events = POLLRDNORM; string name(30, 0); inet_ntop(AF_INET, \u0026amp;clnt_addr.sin_addr, \u0026amp;name[0], name.capacity()); name = string(name.c_str()); name.push_back(\u0026#39;:\u0026#39;); name.append(to_string(ntohs(clnt_addr.sin_port))); names[distance(events.begin(), iter)] = name; cout \u0026lt;\u0026lt; \u0026#34;client \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; connect\u0026#34; \u0026lt;\u0026lt; endl; nready--; } for (int i = 1; i \u0026lt; events.size() \u0026amp; nready; ++i) { if (events[i].fd \u0026lt; 0) continue; if (events[i].revents \u0026amp; (POLLRDNORM | POLLERR)) { string buffer(BUFFER_SIZE, 0); int n; while ((n = recv(events[i].fd, \u0026amp;buffer[0], buffer.capacity(), MSG_DONTWAIT)) \u0026gt; 0) { cout \u0026lt;\u0026lt; names[i] \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34;; output(buffer, n); cout \u0026lt;\u0026lt; endl; write(events[i].fd, \u0026amp;buffer[0], n); } if (n == 0 || errno != EAGAIN) { cout \u0026lt;\u0026lt; \u0026#34;connection of \u0026#34; \u0026lt;\u0026lt; names[i]; if (n == 0) cout \u0026lt;\u0026lt; \u0026#34; was closed\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34; something error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; endl; close(events[i].fd); events[i].fd = -1; } } } if(exiting) break; } cout \u0026lt;\u0026lt; \u0026#34;\\nserver exiting\u0026#34; \u0026lt;\u0026lt; endl; for_each(events.begin(), events.end(), [](auto \u0026amp;mem) { if (mem.fd != -1) close(mem.fd); }); return 0; } 基于epoll的非阻塞echo服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;sys/epoll.h\u0026gt; #include\u0026lt;arpa/inet.h\u0026gt; #include\u0026lt;signal.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;strings.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;algorithm\u0026gt; const short PORT = 65535; const int LISTENQ = 10; const int BUFFER_SIZE = 1024; bool exiting = false; using namespace std; void output(const string \u0026amp;str, int size) { for (int i = 0; i \u0026lt; size; ++i) cout \u0026lt;\u0026lt; str[i]; } void exit_handler(int signum) { exiting = true; } int main() { signal(SIGINT, exit_handler); int serv_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in serv_addr, clnt_addr; int clnt_fd; unsigned addr_len = sizeof(struct sockaddr_in); bzero(\u0026amp;serv_addr, addr_len); serv_addr.sin_port = htons(PORT); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); if (bind(serv_fd, (struct sockaddr*)\u0026amp;serv_addr, addr_len) \u0026lt; 0) { perror(\u0026#34;bind\u0026#34;); exit(0); } listen(serv_fd, LISTENQ); cout \u0026lt;\u0026lt; \u0026#34;server running...\u0026#34; \u0026lt;\u0026lt; endl; int epoll_fd = epoll_create(LISTENQ); struct epoll_event ev; vector\u0026lt;struct epoll_event\u0026gt; events(LISTENQ); vector\u0026lt;int\u0026gt; opened_sockets; map\u0026lt;int, string\u0026gt; names; ev.data.fd = serv_fd; ev.events = EPOLLIN; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, serv_fd, \u0026amp;ev); names[serv_fd] = string(\u0026#34;server\u0026#34;); opened_sockets.push_back(serv_fd); string buffer(BUFFER_SIZE, 0); for (;;) { // Specifying a timeout of -1 causes epoll_wait() to block indefinitely, while specifying a timeout equal to zero cause epoll_wait() to return imme‐ │kevin@kevin-virtual-machine:~/MINE/tingx/build$ ./client // diately, even if no events are available. int nready = epoll_wait(epoll_fd, \u0026amp;events[0], LISTENQ, 100); // timeout = 100ms for (int i = 0; i \u0026lt; nready; ++i) { // new client connection if (events[i].data.fd == serv_fd) { clnt_fd = accept(serv_fd, (struct sockaddr*)\u0026amp;clnt_addr, \u0026amp;addr_len); ev.data.fd = clnt_fd; ev.events = EPOLLIN; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, clnt_fd, \u0026amp;ev); string name(30, 0); inet_ntop(AF_INET, \u0026amp;clnt_addr.sin_addr, \u0026amp;name[0], name.capacity()); name = string(name.c_str()); name.push_back(\u0026#39;:\u0026#39;); name.append(to_string(ntohs(clnt_addr.sin_port))); names[clnt_fd] = name; opened_sockets.push_back(clnt_fd); cout \u0026lt;\u0026lt; \u0026#34;client \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; connected\u0026#34; \u0026lt;\u0026lt; endl; } else { int n; while ((n = recv(events[i].data.fd, \u0026amp;buffer[0], buffer.capacity(), MSG_DONTWAIT)) \u0026gt; 0) { cout \u0026lt;\u0026lt; names[events[i].data.fd] \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026#34;; output(buffer, n); cout \u0026lt;\u0026lt; endl; write(events[i].data.fd, \u0026amp;buffer[0], n); } if (n == 0 || errno != EAGAIN) { cout \u0026lt;\u0026lt; \u0026#34;connection of \u0026#34; \u0026lt;\u0026lt; names[events[i].data.fd]; if (n == 0) cout \u0026lt;\u0026lt; \u0026#34; was closed\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34; something error: \u0026#34; \u0026lt;\u0026lt; strerror(errno) \u0026lt;\u0026lt; endl; close(events[i].data.fd); opened_sockets.erase(find(opened_sockets.begin(), opened_sockets.end(), events[i].data.fd)); epoll_ctl(epoll_fd, EPOLL_CTL_DEL, events[i].data.fd, NULL); } } } if(exiting) break; } cout \u0026lt;\u0026lt; \u0026#34;\\nserver exiting\u0026#34; \u0026lt;\u0026lt; endl; for_each(opened_sockets.begin(), opened_sockets.end(), [](auto \u0026amp;mem) { close(mem); }); return 0; } 参考资料 Linux中的defunct进程(僵尸进程)\nEpoll原理解析\n《UNIX网络编程 卷1：套接字联网API》\n","date":"2022-02-23T00:00:00Z","permalink":"https://nu11able.github.io/p/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BE%8B%E5%AD%90/","title":"Unix网络编程基础篇(例子)"},{"content":"vim使用记录 单按键命令 按键 功能 h 前 j 下 k 上 l 后 ESC 进入nomal模式 i 进入INSERT模式 v 进入选择模式 V 选择整行 y 复制 p 粘贴 0 将光标移到行首(数字0) ^ 将光标移到该行第一个字母位置 $ 将光标移到行位 a 在光标后插入 A 在行尾插入(相当于$a) o 在下一行插入(相当于vscode中ctrl+enter) O 在上一行插入(相当于vscode中ctrl+shift+enter) x 删除一个字符 w 移动至下一个单词开始位置 e 移动至当前单词末尾 b 后退一个单词 u 撤销命令 U？ To undo all the changes on a line p 将粘贴板的内容复制到光标后面(lowercase) P 将粘贴板的内容复制到光标前面(uppercase) 窗口分割 命令 功能 :sp [filename] 水平分割窗口 :vsplit [filename] 垂直分割窗口 Ctrl+w+方向键 切换到前／下／上／后一个窗格 Ctrl+w+h/j/k/l 同上 Ctrl+ww 依次向后切换到下一个窗格中 组合按键命令 按键 功能 dw 删除至下一个单词开始 de 删除至当前单词末尾 dd 删除整行 d$ 删除光标位置到行尾 r? r+任意按键：将光标位置修改为所按按键 ce 删除光标至当前单词末尾并进入INSERT模式(相当于dei) d [number] motion, d: delete c [number] motion, c: change 命令说明 命令 功能 /word 搜索word s/old/new to substitute \u0026rsquo;new\u0026rsquo; for \u0026lsquo;old\u0026rsquo;(只替换一次) s/old/new/g to substitute \u0026rsquo;new\u0026rsquo; for \u0026lsquo;old\u0026rsquo;(修改该行内所有匹配) #,#s/old/new/g where #,# are the line numbers of the range of lines where the substitution is to be done. %s/old/new/g to change every occurrence in the whole file. %s/old/new/gc to find every occurrence in the whole file, with a prompt whether to substitute or not.(c : confirm) !command execute the external command. 其他快捷按键 Type % to find a matching ),], or }\n在[, (或 { 按下 % 可以快速移动到与之匹配的括号处\n在选择模式下按下:进入命令模式w TEST会将选中的内容保存到TEST文件中\n在命令模式下: r FILENAME 会将FILENAME的内容插入到下一行，r !ls将ls命令的执行结果插入到后一行\nTo go back to where you came from press CTRL-O (Keep Ctrl down while pressing the letter o). Repeat to go back further. CTRL-I goes forward.\n","date":"2022-02-20T00:00:00Z","permalink":"https://nu11able.github.io/p/vim/","title":"vim"},{"content":"Chapter 1 gdb startfile\nset width w(a number)\nbreak breakpoint it could be line number|function name|address\nrun\nn next. line\ns step. into the function\nbt backtrace.\np lquote print. the value of lquote\nyou can also use p to assign a specific value to an element,such as p len_lquote=strlen(lquote) We can set them to better values using the p command, since it can print the value of any expression—and that expression can include subroutine calls and assignments.\nl list. the source surrounding the current line(10 lines by default) you can use \u0026ldquo;l 50\u0026rdquo; to display the source surrounding the 50th line c continue.\nChapter 2 Ctrl-d Program exited normally\nq quit. the gdb\nThe most usual way to start gdb is with one argument, specifying an executable program:gdb program You can also start with both an executable program and a core file specified:gdb program core You can, instead, specify a process ID as a second argument or use option -p, if youwant to debug a running process:gdb program 1234|gdb -p 1234\ngdb --args gcc -O2 -c foo.c This will cause gdb to debug gcc, and to set gcc’s command-line arguments (see Section 4.3 [Arguments], page 34) to ‘-O2 -c foo.c.\ngdb \u0026ndash;silent|-quiet|-q Do not print the introductory and copyright message\ngdb \u0026ndash;help | gdb -h\ngdb \u0026ndash;cd directory Run gdb using directory as its working directory, instead of the current direc\u0002tory\n1 2 3 4 5 !command-string Invoke a standard shell to execute command-string. Note that no space is needed between ! and command-string. If it exists, the environment variable SHELL determines which shell to run. Otherwise gdb uses the default shell (‘/bin/sh’ on Unix systems, ‘COMMAND.COM’ on MS-DOS, etc.). pipe [command] | shell_command | [command] | shell_command pipe -d delim command delim shell_command | -d delim command delim shell_command Executes command and sends its output to shell command. Note that no space is needed around |. If no command is provided, the last command executed is repeated. In case the command contains a |, the option -d delim can be used to specify an alternate delimiter string delim that separates the command from the shell command. Example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 (gdb) p var $1 = { black = 144, red = 233, green = 377, blue = 610, white = 987 } (gdb) pipe p var|wc 7 19 80 (gdb) |p var|wc -l 7 (gdb) p /x var $4 = { black = 0x90, red = 0xe9, green = 0x179, blue = 0x262, white = 0x3db } (gdb) ||grep red red =\u0026gt; 0xe9, (gdb) | -d ! echo this contains a | char\\n ! sed -e ’s/|/PIPE/’ this contains a PIPE char (gdb) | -d xxx echo this contains a | char!\\n xxx sed -e ’s/|/PIPE/’ this contains a PIPE char! (gdb) The convenience variables $_shell_exitcode and $_shell_exitsignal can be used to examine the exit status of the last shell command launched by shell, make, pipe and |.\nGDB commands set print elements NUMBER-OF-ELEMENTS set print array-indexes set print elements 10 # to change the limit of array elements to print\n","date":"2022-01-10T00:00:00Z","permalink":"https://nu11able.github.io/p/gdb/","title":"GDB"},{"content":"安装ubuntu 这里我采用的是VMwarePro15虚拟机，实体机上也是一样的步骤，只不过要自己制作启动盘。(本教程写给linux小白看的，当然我自己也比小白好不了多少，其中难免有不当之处，还望告知[也将此篇文章当做自己的一个学习笔记，不定时更新])\n说明一下为啥选择ubuntu，以前刚开始学习使用linux的时候要安装软件通常都不知道名字叫啥，知道命令是apt install xxxxx，就是不知道后面该加什么东西，后面发现ubuntu的提示实在太感人,比如我要使用ifconfig它会提示我安装net-tools，也许其他系统也有只是我没发现，没错！！就因为这个慢慢的爱上ubuntu。233\n开始安装ubuntu18.04 step1 选择稍后安装操作系统 选择linux ubuntu 选择自己的安装位置 在指定磁盘容量的时候如果打算长期使用的话建议磁盘稍微大一点 点击编辑此虚拟机 从CD/DVD中添加自己下载的系统 开启此虚拟机 step2 install ubuntu在这一步你们可以选择chinese，设置系统语言，也可以安装之后再改 一路continue下去就好了 在这一步的时候把Download updates while installing ubuntu那一选项去掉 选择时区 设置用户名和密码这里设置的密码务必记住，待会儿登录大的时候要用 开始安装 发现是不是安装的好慢？告诉你们一个小秘密，其实这里是可以点击skip的安装的过程好像会联网下载什么东西还是啥的我也不是很清楚，如果不放心的话可以断开网络安装 点击重启 输入刚刚设置的密码就可以登录了 ubuntu 美化 首先先来确定一下主要美化哪几个方面:\n壁纸(桌面壁纸、锁屏壁纸) 图标(就是你在桌面上看到的那些图标) 主题(什么是主题？这个我也不好说) 终端terminal(一个漂亮的ubuntu怎么能少了一个漂亮的终端) shell(修改了之后最直观的就是顶部的菜单栏改变了) 开机动画 任务栏 说明一下美化的话需要我们安装插件，你可以通过浏览器来安装插件(前提示已经安装了​chrome-gnome-shell插件)也可以通过命令行来安装(但是有些插件的安装命令我也不知道咋输)，所以安装插件我一般通过浏览器来安装\nstep0：安装​chrome-gnome-shell 1 sudo apt install chrome-gnome-shell 安装好了之后再浏览器输入https://extensions.gnome.org/ 打开之后会有一个警告，点击Click here to install browser extension 安装浏览器拓展，按照提示安装，下载完后点击 Add 即可。 安装完了之后我们可以通过浏览器来管理我们安装的插件(这个时候你可以看到右上角有一个黑色的脚丫子图标,以后直接点击该图标就可以进入“主页”) 我这里安装的插件有些多，这是因为我之前安装gnome-shell-extensions软件包，里面包含了许多插件，你们可以通过apt install gnome-shell-extensions 安装，也可以后面用到啥插件的时候用浏览器安装\nstep1：安装tweak tool（美化软件，在这里你可以设置壁纸、图标、主题\u0026hellip;）、 1 sudo apt install gnome-tweak-tool step2：下载主题、图标等等 简单的说明一下：在官网下载了相应的文件之后，将其解压到相应的位置然后就可以通过tweak这个工具来修改了\n1 2 3 4 themes --\u0026gt; /usr/share/themes shell --\u0026gt; /usr/share/themes icon --\u0026gt; /usr/share/icons 开机动画 --\u0026gt; /usr/share/plymouth/themes 官网 我这里直接给出几个链接\n主题\n图标\nshell\n登录界面 下载的时候注意自己的系统版本，别下错了\n开机动画 我承认我放弃了，可能是虚拟机的原因(修改了也没起作用)\nstep3：前面准备工作已经做完了，下面开始正式修改 ok，前面已经下载了需要的文件，可以开始修改了，除了开机动画之外其他的很简单，把下载的文件解压后发到对应的目录下，打开tweaks就可以修改了\n下载主题的时候我多下载了几个主题，图中我标出了shell和icon其他的都是主题 下面分别把文件解压之后移动到对应的目录下\n1 2 3 4 5 # 解压命令 tar xf 你下载的文件 # 将解压的文件移动到对应的目录，shell和主题都是移动到usr/share/themes/ 目录下，icon移动到/usr/shar/icons/ mv 目标文件 目的地 做好这些之后可以先右键选张好看的背景(通过前面的类比你可以发现/usr/share/backgrounds里面存放的就是壁纸) 打开tweak修改成我们下载的文件 修改之后 将任务栏发到下边居中 有的人喜欢透明的terminal step4：修改登录界面 将下载的gdm themes文件解压之后进入运行install脚本即可 按照提示alt+f2应用我们所做的修改 查看一下效果 ??这个背景怎么不太对？下面将记录我解决这一问题的思路；通常我认为授人以鱼不如授人以渔，以前刚入门linux的时候遇到的问题就网上搜索解决方案，但网络上通常直接给出几条命令，至于为什么是这样修改的就不知道了；现在慢慢的熟悉了linux之后也渐渐的懂得了如何查找问题所在。\n现在使用vim查看一线我们使用的安装脚本，就是那个install脚本\n1 vim install.sh 第一行我们可以看到它将文件下的一个.css文件复制到了/usr/share/gnome-shell/theme/ubuntu.css 之前查找如何修改锁屏壁纸的时候总是需要去修改/etc/alternatives/gdm3.css的文件，其实这个文件就是连接到/usr/share/gnome-shell/theme/ubuntu.css的。就相当于是windows下的快捷方式一样 那么现在思路就清晰了，安装脚本替换了我们电脑上原本的按个.css样式文件，但是现在锁屏壁纸异常，那么我们查看gdm3.css文件下有关锁屏壁纸的那一部分就可以找到答案了，找到lockDialogGroup，可以看到background是一个url的本地链接，用文件打开到相应的目录并没有发现一个叫gdmlock.jpg的图片，那么现在应该清楚为什么显示异常了 修改一个自己喜欢的背景 问题解决 step5：安装zsh美化终端 参考链接1\n参考链接2\n啥时候有空再自己写一个吧\nstep6：开机动画 经供参考，我自己也没成功233\n虽然没有成功，单也做一个自己的学习记录吧，不知道是不是虚拟机的问题(如果哪位老哥虚拟机下能够修改成功还望能够分享一下)\n将下载的plymouth theme解压到/usr/share/plymouth/themes目录下\n执行命令\n1 2 3 4 5 6 7 sudo update-alternatives --install /usr/share/plymouth/themes/default.plymouth default.plymouth /usr/share/plymouth/themes/\u0026#34;path/to-your-plymouth.plymouth\u0026#34; 100 sudo update-initramfs -u #应用修改 # 也可以 sudo update-alternatives --config default.plymouth 其实主要修改的是 但是我修改之后发现没有ScriptFile字段可能这就是原因(但是我下载的文件里本就没有.script文件\u0026hellip;后面再查一下资料吧) 常见问题解决 解决虚拟机窗口大小无法改变(安装VMware tools) 点击虚拟机-\u0026gt;安装VMware tools 此时桌面上出现了一个DVD光盘的图标，然后我们右键-\u0026gt;Open terminal 打开命令行(当你习惯命令行之后会发现命令行使用起来是如此的自然、简介、唯美) emm\u0026hellip;这里看起来好像不是很清楚，我把我的命令列举并说明一下吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 lsblk #这个命令我就不说了 我一般拿来查看有哪些挂载点的 一般都会在/media目录下 其他的对于新手来说先不用管(其实我也不是很清楚) cd /media/learning/VMware\\ Tools/ #进入这个指定的目录 这个地方learning应该是你自己的用户名 tips:按tab键会自动补全 ls #查看当前目录下有哪些东西 看到红色的那个压缩包了没，那就是我们需要的东西了 mv VMwareTools-10.3.10-13959562.tar.gz ~ #将压缩包移动到我们账户的主目录下 cd ~ #进入我们的主目录 ls #查看当前目录下有哪些东西 tar -xf VMwareTools-10.3.10-13959562.tar.gz #将压缩包解压 cd vmware-tools-distrib/ #进入解压之后的文件 ls #查看当前目录下有哪些东西 sudo vmware-install.pl # 执行安装脚本开始安装 这个时候需要你输入密码(输入的密码是不可见的，你的键盘没坏) #下面是不带注释的版本 lsblk cd /media/learning/VMware\\ Tools/ ls mv VMwareTools-10.3.10-13959562.tar.gz ~ cd ~ ls tar -xf VMwareTools-10.3.10-13959562.tar.gz cd vmware-tools-distrib/ sudo vmware-install.pl 开始安装之后一路回车下去就ok了(全选默认) 然后就可以看到窗口完美的匹配上了 解决安装软件慢的问题(所谓的linux安装之后必做的事之一\u0026ndash;换源) 大概说一下吧换源是个怎么回事吧(个人理解)：我们使用windows安装软件的时候都会去网上找资源然后下载，然而在linux里面当你使用命令行(当然你也可以像使用windows一样去网上找[有一些是不得不这么做])apt install 等命令安装东西的时候(你可以以为apt就是windows下的软件管家，[其实我就是这么以为的])它会去它的仓库找你要安装的软件然后下载下来给你装上，默认的仓库位置是国外的，所以下载的速度会非常非常非常慢，换源就是给它换个仓库的意思。下面开始进入正题:\n再扯两句:linux下很多东西都是可以配置的，而这些配置规则有一个专门的文件来存储\n1 2 cd /etc/apt ls 可以看到有一个sources.list文件 查看一下这个文件的内容是啥vi sources.list # vi 是vim的前身(可以看到有很多东西都是被注释掉的，#号开头的就是被注释掉的 那几个没有被注释掉的网址就是仓库的位置) ！！！！我怎么退出不了？？！！！自己去百度一下vi怎么退出！哈哈哈！！\n现在开始换源，换源之前先另存一份sudo mv sources.list sources.list.backup(后面有空再说sudo命令) 我比较喜欢用清华的源 如果安装了VMware tools还是无法拖动的话重启一下 右键-\u0026gt;Open Terminal ls查看一下当前目录，sudo mv Desktop/sources.list /etc/apt将桌面的sources.list文件移动到/etc/apt目录下，cd /etc/apt进入/etc/apt目录。ls查看一下当前目录发现sources.list是绿色的，sources.list原本不是绿色的现在它怎么能和原来不一样呢？？？作为一个追求完美的人是绝对无法忍受的，它是绿色的说明它拥有可执行权限，我把它的可执行权限给它拿掉就行了chmod a-x sources.list(拥有可执行权限就相当于是windows下的.exe)。ls 再次查看一下，嗯\u0026hellip;现在完美了\n1 2 3 4 5 6 ls sudo mv Desktop/sources.list /etc/apt cd /etc/apt ls chmod a-x sources.list ls 安装pip3并更换源(解决pip安装东西慢的问题) ubuntu默认是没有安装pip的(由于我主要使用python3，所以我只装pip3),安装完之后查看一下是否安装成功pip3 -V\n1 2 sudo apt install python3-pip pip3 -V 下面更换pip源，让我们pip install的时候速度更快\n解决方法一 https://pypi.tuna.tsinghua.edu.cn/simple 解决方法二 图片来自https://blog.csdn.net/qq_14994573/article/details/80934201 emm..亲测解决方法一不太行(貌似升级不行，我也不知道为啥) 那就来方法二 ```bash cd ~ ls -al #查看是否存在.pip文件夹 mkdir .pip #创建.pip文件夹 vim pip/pip.conf #自己百度下vim怎么用\n1 2 3 4 5 6 7 8 改好之后试一下效果 ![](更换pip源7.png) ## 首次登陆怎么设置root用户？(首次登陆需要为root用户设置密码) 输入命令sudo passwd然后输入你当前用户的密码(还记得每次使用sudo命令都要输当前用户密码吗？)然后就可以设置root用户的密码了，更改完了使用su root命令试试效果 ```bash sudo passwd su root whoami 挂载移动硬盘出现mount:unknown filesystem type \u0026rsquo;exfat' 出现这个错误说明缺少对exfat文件系统的支持\n1 2 3 4 5 6 7 # 搜索一下与exfat相关的东西 apt search exfat # 可以看到exfat-fuse 是 对exfat文件系统的支持 # read and write exFAT driver for FUSE apt install exfat-fuse # 安装好了之后再重新挂载就ok了 安装杂七杂八的软件 安装gcc g++ python3 vim 细细盘算一下作为一个计算机相关的精神小伙必不可少的有哪些东西呢？gcc g++ python vim\u0026hellip;先暂时安装这几个吧其它的后面再说(这个地方安装的是python2，python3 ubuntu18.04默认安装了的)\n1 2 3 4 5 6 7 8 9 # 废话不多说，直接一条命令搞定 sudo apt update sudo apt install gcc g++ python vim --yes # 当然你也可以 # sudo apt install gcc # sudo apt install g++ # sudo apt install python # sudo apt install vim 安装完了之后使用\u0026ndash;version参数查看是否安装成功 作为一个精通helloworld的人，我飞快的写了一行helloworld并运行成功，顿时心潮澎湃热血上涌。 安装open-ssh并试用vscode“远程”编辑代码 说到这里其实当我们在terminal里面敲ssh之后按两下tab之后其实可以看到已经安装了一写ssh相关的软件，只不过我们要在外部连接到我们“主机”，那么自然就需要ssh server相关的东西，ubuntu并没有默认安装，搜索一下ssh-server，可以看到openssh-server正是我们要的东西，然后直接安装就行了\n1 2 apt search ssh-server apt install openssh-server 安装完了查看一下是否在运行\n1 2 3 service sshd status # 如果没运行的话可以: # service sshd start 下面我们用xshell连接试试，配置好相关信息我选择以root用户登录 再疯狂的重试了输入root密码并确定没有输入错误后我决定查看一下登录日志，然鹅并没有看出什么东西密码不可能输错 没办法我换个用户登录试试，TMD(实在忍不住爆句粗口)，成功了 下面再用vscode连接试试，这样可以方便写代码(貌似也没方便多少233，如果是连服务器的话倒是方便了很多) 选择一个文件保存配置的信息(就是你刚刚输入的用户名和地址) 保存好了就可以连接了 连接好了之后可以打开文件看看 ","date":"2020-05-03T00:00:00Z","permalink":"https://nu11able.github.io/p/ubuntu%E5%AE%89%E8%A3%85%E5%8F%8A%E7%BE%8E%E5%8C%96/","title":"ubuntu安装及美化"}]